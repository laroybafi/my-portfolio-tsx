"use client";

// src/use-input.ts
import { mapPropsVariants } from "@nextui-org/system";
import { useFocusRing } from "@react-aria/focus";
import { input } from "@nextui-org/theme";
import { useDOMRef, filterDOMProps } from "@nextui-org/react-utils";
import { useHover, usePress } from "@react-aria/interactions";
import { clsx, dataAttr, safeAriaLabel } from "@nextui-org/shared-utils";
import { useControlledState } from "@react-stately/utils";
import { useMemo, useCallback } from "react";
import { chain, mergeProps } from "@react-aria/utils";
import { useTextField } from "@react-aria/textfield";
function useInput(originalProps) {
  var _a, _b;
  const [props, variantProps] = mapPropsVariants(originalProps, input.variantKeys);
  const {
    ref,
    as,
    label,
    description,
    errorMessage,
    className,
    classNames,
    autoFocus,
    startContent,
    endContent,
    onClear,
    onChange,
    onValueChange = () => {
    },
    ...otherProps
  } = props;
  const handleValueChange = useCallback(
    (value) => {
      onValueChange(value != null ? value : "");
    },
    [onValueChange]
  );
  const [inputValue, setInputValue] = useControlledState(
    (_a = props.value) != null ? _a : void 0,
    (_b = props.defaultValue) != null ? _b : void 0,
    handleValueChange
  );
  const Component = as || "div";
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className, !!inputValue ? "is-filled" : "");
  const isMultiline = originalProps.isMultiline;
  const domRef = useDOMRef(ref);
  const handleClear = useCallback(() => {
    setInputValue("");
    if (domRef.current) {
      domRef.current.value = "";
      domRef.current.focus();
    }
    onClear == null ? void 0 : onClear();
  }, [domRef, setInputValue, onClear]);
  const { labelProps, inputProps, descriptionProps, errorMessageProps } = useTextField(
    {
      ...originalProps,
      "aria-label": safeAriaLabel(
        originalProps == null ? void 0 : originalProps["aria-label"],
        originalProps == null ? void 0 : originalProps.label,
        originalProps == null ? void 0 : originalProps.placeholder
      ),
      inputElementType: isMultiline ? "textarea" : "input",
      value: inputValue,
      onChange: setInputValue
    },
    domRef
  );
  const { isFocusVisible, isFocused, focusProps } = useFocusRing({
    autoFocus,
    isTextInput: true
  });
  const { isHovered, hoverProps } = useHover({ isDisabled: !!(originalProps == null ? void 0 : originalProps.isDisabled) });
  const { focusProps: clearFocusProps, isFocusVisible: isClearButtonFocusVisible } = useFocusRing();
  const { pressProps: clearPressProps } = usePress({
    isDisabled: !!(originalProps == null ? void 0 : originalProps.isDisabled),
    onPress: handleClear
  });
  const isInvalid = props.validationState === "invalid";
  const labelPlacement = useMemo(() => {
    var _a2;
    if ((!originalProps.labelPlacement || originalProps.labelPlacement === "inside") && !label) {
      return "outside";
    }
    return (_a2 = originalProps.labelPlacement) != null ? _a2 : "inside";
  }, [originalProps.labelPlacement, label]);
  const isLabelPlaceholder = !props.placeholder && labelPlacement !== "outside-left" && !isMultiline;
  const isClearable = !!onClear || originalProps.isClearable;
  const hasElements = !!label || !!description || !!errorMessage;
  const hasPlaceholder = !!props.placeholder;
  const hasHelper = !!description || !!errorMessage;
  const shouldLabelBeOutside = labelPlacement === "outside" || labelPlacement === "outside-left";
  const shouldLabelBeInside = labelPlacement === "inside";
  const hasStartContent = !!startContent;
  const slots = useMemo(
    () => input({
      ...variantProps,
      isInvalid,
      isClearable,
      labelPlacement,
      isLabelPlaceholder: isLabelPlaceholder && !hasStartContent
    }),
    [
      ...Object.values(variantProps),
      isInvalid,
      labelPlacement,
      isClearable,
      isLabelPlaceholder,
      hasStartContent
    ]
  );
  const getBaseProps = useCallback(
    (props2 = {}) => {
      return {
        className: slots.base({ class: baseStyles }),
        "data-focus-visible": dataAttr(isFocusVisible),
        "data-readonly": dataAttr(originalProps.isReadOnly),
        "data-focus": dataAttr(isFocused),
        "data-hover": dataAttr(isHovered),
        "data-required": dataAttr(originalProps.isRequired),
        "data-invalid": dataAttr(isInvalid),
        "data-disabled": dataAttr(originalProps.isDisabled),
        "data-has-elements": dataAttr(hasElements),
        "data-has-helper": dataAttr(hasHelper),
        ...props2
      };
    },
    [
      slots,
      baseStyles,
      isFocused,
      isHovered,
      isInvalid,
      hasHelper,
      hasElements,
      isFocusVisible,
      originalProps.isReadOnly,
      originalProps.isRequired,
      originalProps.isDisabled
    ]
  );
  const getLabelProps = useCallback(
    (props2 = {}) => {
      return {
        className: slots.label({ class: classNames == null ? void 0 : classNames.label }),
        ...labelProps,
        ...props2
      };
    },
    [slots, labelProps, classNames == null ? void 0 : classNames.label]
  );
  const getInputProps = useCallback(
    (props2 = {}) => {
      return {
        ref: domRef,
        className: slots.input({ class: clsx(classNames == null ? void 0 : classNames.input, !!inputValue ? "is-filled" : "") }),
        ...mergeProps(
          focusProps,
          inputProps,
          filterDOMProps(otherProps, {
            enabled: true,
            labelable: true,
            omitEventNames: new Set(Object.keys(inputProps))
          }),
          props2
        ),
        required: originalProps.isRequired,
        "aria-readonly": dataAttr(originalProps.isReadOnly),
        "aria-required": dataAttr(originalProps.isRequired),
        onChange: chain(inputProps.onChange, onChange)
      };
    },
    [
      slots,
      inputValue,
      focusProps,
      inputProps,
      otherProps,
      classNames == null ? void 0 : classNames.input,
      originalProps.isReadOnly,
      originalProps.isRequired,
      onChange
    ]
  );
  const getInputWrapperProps = useCallback(
    (props2 = {}) => {
      return {
        "data-hover": dataAttr(isHovered),
        className: slots.inputWrapper({
          class: clsx(classNames == null ? void 0 : classNames.inputWrapper, !!inputValue ? "is-filled" : "")
        }),
        onClick: (e) => {
          var _a2;
          if (e.target === e.currentTarget) {
            (_a2 = domRef.current) == null ? void 0 : _a2.focus();
          }
        },
        ...mergeProps(props2, hoverProps),
        style: {
          cursor: "text",
          ...props2.style
        }
      };
    },
    [slots, isHovered, inputValue, classNames == null ? void 0 : classNames.inputWrapper]
  );
  const getInnerWrapperProps = useCallback(
    (props2 = {}) => {
      return {
        ...props2,
        className: slots.innerWrapper({
          class: clsx(classNames == null ? void 0 : classNames.innerWrapper, props2 == null ? void 0 : props2.className)
        })
      };
    },
    [slots, classNames == null ? void 0 : classNames.innerWrapper]
  );
  const getMainWrapperProps = useCallback(
    (props2 = {}) => {
      return {
        ...props2,
        className: slots.mainWrapper({
          class: clsx(classNames == null ? void 0 : classNames.mainWrapper, props2 == null ? void 0 : props2.className)
        })
      };
    },
    [slots, classNames == null ? void 0 : classNames.mainWrapper]
  );
  const getHelperWrapperProps = useCallback(
    (props2 = {}) => {
      return {
        ...props2,
        className: slots.helperWrapper({
          class: clsx(classNames == null ? void 0 : classNames.helperWrapper, props2 == null ? void 0 : props2.className)
        })
      };
    },
    [slots, classNames == null ? void 0 : classNames.helperWrapper]
  );
  const getDescriptionProps = useCallback(
    (props2 = {}) => {
      return {
        ...props2,
        ...descriptionProps,
        className: slots.description({ class: clsx(classNames == null ? void 0 : classNames.description, props2 == null ? void 0 : props2.className) })
      };
    },
    [slots, classNames == null ? void 0 : classNames.description]
  );
  const getErrorMessageProps = useCallback(
    (props2 = {}) => {
      return {
        ...props2,
        ...errorMessageProps,
        className: slots.errorMessage({ class: clsx(classNames == null ? void 0 : classNames.errorMessage, props2 == null ? void 0 : props2.className) })
      };
    },
    [slots, errorMessageProps, classNames == null ? void 0 : classNames.errorMessage]
  );
  const getClearButtonProps = useCallback(
    (props2 = {}) => {
      return {
        ...props2,
        role: "button",
        tabIndex: 0,
        "data-focus-visible": dataAttr(isClearButtonFocusVisible),
        className: slots.clearButton({ class: clsx(classNames == null ? void 0 : classNames.clearButton, props2 == null ? void 0 : props2.className) }),
        ...mergeProps(clearPressProps, clearFocusProps)
      };
    },
    [slots, isClearButtonFocusVisible, clearPressProps, clearFocusProps, classNames == null ? void 0 : classNames.clearButton]
  );
  return {
    Component,
    classNames,
    domRef,
    label,
    description,
    startContent,
    endContent,
    labelPlacement,
    isClearable,
    isInvalid,
    hasHelper,
    shouldLabelBeOutside,
    shouldLabelBeInside,
    hasPlaceholder,
    errorMessage,
    getBaseProps,
    getLabelProps,
    getInputProps,
    getMainWrapperProps,
    getInputWrapperProps,
    getInnerWrapperProps,
    getHelperWrapperProps,
    getDescriptionProps,
    getErrorMessageProps,
    getClearButtonProps
  };
}

export {
  useInput
};
